

const fs = require('fs');
const path = require('path');

// --- PATHS ---
const ROOT_DIR = path.join(__dirname, '..');
const UPLOADS_DIR = path.join(ROOT_DIR, 'upload');
const PUBLIC_FILES_DIR = path.join(ROOT_DIR, 'public', 'files');
const DATA_DIR = path.join(ROOT_DIR, 'data');
const QUIZ_ORDER_PATH = path.join(PUBLIC_FILES_DIR, 'quiz-order.json');
const QUIZZES_TS_PATH = path.join(DATA_DIR, 'quizzes.ts');
const COMMIT_MESSAGE_PATH = path.join(ROOT_DIR, 'commit_message.txt');
const LINKS_OUTPUT_PATH = path.join(UPLOADS_DIR, 'new_quiz_links.txt');

// --- MAIN LOGIC ---
function main() {
    // All logic is now consolidated into a single, sequential function.
    updateQuizData();
}

/**
 * Processes new files, updates quiz-order.json, and regenerates data/quizzes.ts in a single, sequential flow.
 */
function updateQuizData() {
    // 1. Handle new uploads
    if (!fs.existsSync(UPLOADS_DIR)) fs.mkdirSync(UPLOADS_DIR);
    
    const newFiles = fs.readdirSync(UPLOADS_DIR).filter(f => f.endsWith('.json'));
    const quizOrder = JSON.parse(fs.readFileSync(QUIZ_ORDER_PATH, 'utf-8'));
    const newFilesInfo = [];

    for (const jsonFile of newFiles) {
        const pdfFile = jsonFile.replace('.json', '.pdf');
        if (!fs.existsSync(path.join(UPLOADS_DIR, pdfFile))) {
            console.warn(`[Warning] Missing PDF for ${jsonFile}. Skipping.`);
            continue;
        }
        fs.renameSync(path.join(UPLOADS_DIR, jsonFile), path.join(PUBLIC_FILES_DIR, jsonFile));
        fs.renameSync(path.join(UPLOADS_DIR, pdfFile), path.join(PUBLIC_FILES_DIR, pdfFile));
        
        quizOrder.push(jsonFile); // Update order in memory
        newFilesInfo.push({ fileName: jsonFile, id: quizOrder.length - 1 });
        console.log(`Processed and moved: ${jsonFile}`);
    }

    // 2. Clean up quiz-order.json from ghost files
    const originalCount = quizOrder.length;
    const cleanedQuizOrder = quizOrder.filter(fileName => {
        const exists = fs.existsSync(path.join(PUBLIC_FILES_DIR, fileName));
        if (!exists) {
            console.warn(`[Cleaning] Removing ghost file from quiz order: ${fileName}`);
        }
        return exists;
    });

    if (cleanedQuizOrder.length < originalCount) {
        console.log(`Cleaned ${originalCount - cleanedQuizOrder.length} ghost entries.`);
    }

    // 3. Regenerate quizzes.ts using the final, correct order
    console.log('Regenerating data/quizzes.ts with correct order...');
    const allQuizzesData = [];
    for (let i = 0; i < cleanedQuizOrder.length; i++) {
        const fileName = cleanedQuizOrder[i];
        const filePath = path.join(PUBLIC_FILES_DIR, fileName);
        try {
            const quizDetail = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
            const baseName = path.basename(fileName, '.json');
            allQuizzesData.push({
                id: i,
                title: quizDetail.title || '제목 없음',
                examType: quizDetail.examType || '기타',
                subject: quizDetail.subject || '기타',
                date: quizDetail.date || new Date().toISOString().split('T')[0],
                fileUrl: `/files/${encodeURIComponent(baseName)}.pdf`,
                jsonUrl: `/files/${encodeURIComponent(fileName)}`,
                tags: quizDetail.tags || [],
                difficulty: quizDetail.difficulty || '보통'
            });
        } catch (e) {
            console.error(`[Error] Failed to process ${fileName}. It might be corrupted. Skipping.`, e);
        }
    }

    const tsFileContent = `
// This file is auto-generated by scripts/add-new-quizzes.cjs. DO NOT EDIT MANUALLY.

export interface Quiz {
  id: number;
  title: string;
  examType: string;
  subject: string | { main: string; sub: string };
  size?: string;
  date: string;
  fileUrl?: string;
  jsonUrl?: string;
  shortsLink?: string;
  tags?: string[];
  difficulty?: string;
}

export const quizzes: Quiz[] = ${JSON.stringify(allQuizzesData, null, 2)};
`;

    // 4. Write all changes to disk at the end
    fs.writeFileSync(QUIZ_ORDER_PATH, JSON.stringify(cleanedQuizOrder, null, 2), 'utf-8');
    fs.writeFileSync(QUIZZES_TS_PATH, tsFileContent.trim(), 'utf-8');
    console.log('Successfully updated quiz-order.json and regenerated data/quizzes.ts.');

    // 5. Create output files for user
    if (newFilesInfo.length > 0) {
        createOutputFiles(newFilesInfo);
    }
    console.log('\nScript finished successfully!');
}

/**
 * Creates the commit message and the links file for sharing.
 */
function createOutputFiles(newFiles) {
    let commitMessageBody = '';
    let linksOutput = '';

    for (const fileInfo of newFiles) {
        const { subject, title, difficulty } = parseFilename(fileInfo.fileName);
        commitMessageBody += `- [${subject}] ${title} (${difficulty})\n`;

        const solveUrl = `https://munjero.xyz/#/solve/${fileInfo.id}`;
        const quizUrl = `https://munjero.xyz/#/quiz/${fileInfo.id}`;
        linksOutput += `[${subject}] ${title} (${difficulty})\n`;
        linksOutput += `문제 풀어보기: ${solveUrl}\n`;
        linksOutput += `문제 다운로드: ${quizUrl}\n\n`;
    }

    const fullCommitMessage = `feat: Add new quizzes\n\n${commitMessageBody}`;
    fs.writeFileSync(COMMIT_MESSAGE_PATH, fullCommitMessage, 'utf-8');
    console.log(`Successfully created commit message file.`);

    fs.writeFileSync(LINKS_OUTPUT_PATH, linksOutput, 'utf-8');
    console.log(`Successfully created links file.`);
}

/**
 * Parses metadata from a filename.
 */
function parseFilename(filename) {
    const basename = path.basename(filename, path.extname(filename));
    const parts = basename.split('_');
    if (parts.length >= 3) {
        return { subject: parts[0], title: parts.slice(1, -1).join('_'), difficulty: parts[parts.length - 1] };
    } else {
        return { subject: '기타', title: basename, difficulty: '보통' };
    }
}

// --- RUN SCRIPT ---
main();
