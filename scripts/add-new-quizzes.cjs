


const fs = require('fs');
const path = require('path');

// --- PATHS ---
const ROOT_DIR = path.join(__dirname, '..');
const UPLOADS_DIR = path.join(ROOT_DIR, 'upload');
const PUBLIC_FILES_DIR = path.join(ROOT_DIR, 'public', 'files');
const DATA_DIR = path.join(ROOT_DIR, 'data');
const QUIZ_ORDER_PATH = path.join(PUBLIC_FILES_DIR, 'quiz-order.json');
const QUIZZES_TS_PATH = path.join(DATA_DIR, 'quizzes.ts');
const COMMIT_MESSAGE_PATH = path.join(ROOT_DIR, 'commit_message.txt');
const LINKS_OUTPUT_PATH = path.join(UPLOADS_DIR, 'new_quiz_links.txt');

function main() {
    const quizOrder = JSON.parse(fs.readFileSync(QUIZ_ORDER_PATH, 'utf-8'));

    // 1. Process new files and get their info
    const newFilesInfo = processUploads(quizOrder);

    // 2. Regenerate quizzes.ts based on the single source of truth: quiz-order.json
    const { ghostMissing, ghostParse } = regenerateQuizzesTs(quizOrder);

    // 3. Create output files for the user
    createOutputFiles(newFilesInfo, ghostMissing, ghostParse);

    console.log('\nScript finished successfully!');
}

function processUploads(quizOrder) {
    if (!fs.existsSync(UPLOADS_DIR)) fs.mkdirSync(UPLOADS_DIR);

    const newFilesInUpload = fs.readdirSync(UPLOADS_DIR).filter(f => f.endsWith('.json'));
    if (newFilesInUpload.length === 0) {
        console.log("No new files in /upload directory to process.");
        return [];
    }

    const newFilesInfo = [];

    for (const jsonFile of newFilesInUpload) {
        const pdfFile = jsonFile.replace('.json', '.pdf');
        if (!fs.existsSync(path.join(UPLOADS_DIR, pdfFile))) {
            console.warn(`[Warning] Missing PDF for ${jsonFile}. Skipping.`);
            continue;
        }
        fs.renameSync(path.join(UPLOADS_DIR, jsonFile), path.join(PUBLIC_FILES_DIR, jsonFile));
        fs.renameSync(path.join(UPLOADS_DIR, pdfFile), path.join(PUBLIC_FILES_DIR, pdfFile));
        
        quizOrder.unshift(jsonFile); // Add to the beginning
        newFilesInfo.push({ fileName: jsonFile, id: quizOrder.length - 1 }); // ID will be based on new length
        console.log(`Processed and moved: ${jsonFile}`);
    }

    // IMPORTANT: Write the updated order back to disk so it persists.
    fs.writeFileSync(QUIZ_ORDER_PATH, JSON.stringify(quizOrder, null, 2), 'utf-8');
    console.log(`Successfully updated quiz-order.json with ${newFilesInfo.length} new entries.`);
    return newFilesInfo;
}

function regenerateQuizzesTs(quizOrder) {
    console.log('Regenerating data/quizzes.ts...');
    
    const quizzesOut = [];
    const ghostMissing = [];
    const ghostParse = [];

    for (let i = 0; i < quizOrder.length; i++) {
        const fileName = quizOrder[i];
        const filePath = path.join(PUBLIC_FILES_DIR, fileName);

        if (!fs.existsSync(filePath)) {
            ghostMissing.push(fileName);
            continue;
        }

        try {
            const detail = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
            const base = path.basename(fileName, '.json');
            quizzesOut.push({
                id: i, // ID is the original index, ensuring stability
                title: detail.title || '제목 없음',
                examType: detail.examType || '기타',
                subject: detail.subject || '기타',
                date: detail.date || new Date().toISOString().split('T')[0],
                fileUrl: `/files/${encodeURIComponent(base)}.pdf`,
                jsonUrl: `/files/${encodeURIComponent(fileName)}`,
                tags: detail.tags || [],
                difficulty: detail.difficulty || '보통'
            });
        } catch (e) {
            ghostParse.push(fileName);
        }
    }

    const tsFileContent = `\n// This file is auto-generated by scripts/add-new-quizzes.cjs. DO NOT EDIT MANUALLY.\n\nexport interface Quiz {\n  id: number;\n  title: string;\n  examType: string;\n  subject: string | { main: string; sub: string };\n  size?: string;\n  date: string;\n  fileUrl?: string;\n  jsonUrl?: string;\n  shortsLink?: string;\n  tags?: string[];\n  difficulty?: string;\n}\n\nexport const quizzes: Quiz[] = ${JSON.stringify(quizzesOut, null, 2)};\n`;

    fs.writeFileSync(QUIZZES_TS_PATH, tsFileContent.trim(), 'utf-8');
    console.log(`Successfully regenerated data/quizzes.ts with ${quizzesOut.length} valid quizzes.`);
    return { ghostMissing, ghostParse };
}

function createOutputFiles(newFiles, ghostMissing, ghostParse) {
    if (newFiles.length > 0) {
        let commitMessageBody = '';
        let linksOutput = '';
        for (const fileInfo of newFiles) {
            const { subject, title, difficulty } = parseFilename(fileInfo.fileName);
            commitMessageBody += `- [${subject}] ${title} (${difficulty})\n`;
            const solveUrl = `https://munjero.xyz/#/solve/${fileInfo.id}`;
            const quizUrl = `https://munjero.xyz/#/quiz/${fileInfo.id}`;
            linksOutput += `[${subject}] ${title} (${difficulty})\n`;
            linksOutput += `문제 풀어보기: ${solveUrl}\n`;
            linksOutput += `문제 다운로드: ${quizUrl}\n\n`;
        }
        const fullCommitMessage = `feat: Add new quizzes\n\n${commitMessageBody}`;
        fs.writeFileSync(COMMIT_MESSAGE_PATH, fullCommitMessage, 'utf-8');
        fs.writeFileSync(LINKS_OUTPUT_PATH, linksOutput, 'utf-8');
        console.log(`Successfully created output files for new quizzes.`);
    }

    if (ghostMissing.length || ghostParse.length) {
        let report = '\n------------------------------------\n';
        report += '[자동 청소 리포트]\n';
        report += '------------------------------------\n';
        if (ghostMissing.length) {
            report += '[존재하지 않는 파일]\n' + ghostMissing.join('\n') + '\n\n';
        }
        if (ghostParse.length) {
            report += '[데이터 파싱 실패]\n' + ghostParse.join('\n') + '\n';
        }
        fs.appendFileSync(LINKS_OUTPUT_PATH, report);
        console.log(`Cleanup report appended to ${LINKS_OUTPUT_PATH}.`);
    }
}

function parseFilename(filename) {
    const basename = path.basename(filename, path.extname(filename));
    const parts = basename.split('_');
    if (parts.length >= 3) {
        return { subject: parts[0], title: parts.slice(1, -1).join('_'), difficulty: parts[parts.length - 1] };
    } else {
        return { subject: '기타', title: basename, difficulty: '보통' };
    }
}

main();

